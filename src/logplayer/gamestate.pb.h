// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gamestate.proto

#ifndef PROTOBUF_gamestate_2eproto__INCLUDED
#define PROTOBUF_gamestate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "ssl_referee.pb.h"
// @@protoc_insertion_point(includes)

namespace amun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gamestate_2eproto();
void protobuf_AssignDesc_gamestate_2eproto();
void protobuf_ShutdownFile_gamestate_2eproto();

class GameState;

enum GameState_State {
  GameState_State_Halt = 1,
  GameState_State_Stop = 2,
  GameState_State_Game = 3,
  GameState_State_GameForce = 4,
  GameState_State_KickoffYellowPrepare = 5,
  GameState_State_KickoffYellow = 6,
  GameState_State_PenaltyYellowPrepare = 7,
  GameState_State_PenaltyYellow = 8,
  GameState_State_DirectYellow = 9,
  GameState_State_IndirectYellow = 10,
  GameState_State_KickoffBluePrepare = 11,
  GameState_State_KickoffBlue = 12,
  GameState_State_PenaltyBluePrepare = 13,
  GameState_State_PenaltyBlue = 14,
  GameState_State_DirectBlue = 15,
  GameState_State_IndirectBlue = 16,
  GameState_State_TimeoutYellow = 17,
  GameState_State_TimeoutBlue = 18
};
bool GameState_State_IsValid(int value);
const GameState_State GameState_State_State_MIN = GameState_State_Halt;
const GameState_State GameState_State_State_MAX = GameState_State_TimeoutBlue;
const int GameState_State_State_ARRAYSIZE = GameState_State_State_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameState_State_descriptor();
inline const ::std::string& GameState_State_Name(GameState_State value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameState_State_descriptor(), value);
}
inline bool GameState_State_Parse(
    const ::std::string& name, GameState_State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameState_State>(
    GameState_State_descriptor(), name, value);
}
// ===================================================================

class GameState : public ::google::protobuf::Message {
 public:
  GameState();
  virtual ~GameState();

  GameState(const GameState& from);

  inline GameState& operator=(const GameState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameState& default_instance();

  void Swap(GameState* other);

  // implements Message ----------------------------------------------

  GameState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameState& from);
  void MergeFrom(const GameState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameState_State State;
  static const State Halt = GameState_State_Halt;
  static const State Stop = GameState_State_Stop;
  static const State Game = GameState_State_Game;
  static const State GameForce = GameState_State_GameForce;
  static const State KickoffYellowPrepare = GameState_State_KickoffYellowPrepare;
  static const State KickoffYellow = GameState_State_KickoffYellow;
  static const State PenaltyYellowPrepare = GameState_State_PenaltyYellowPrepare;
  static const State PenaltyYellow = GameState_State_PenaltyYellow;
  static const State DirectYellow = GameState_State_DirectYellow;
  static const State IndirectYellow = GameState_State_IndirectYellow;
  static const State KickoffBluePrepare = GameState_State_KickoffBluePrepare;
  static const State KickoffBlue = GameState_State_KickoffBlue;
  static const State PenaltyBluePrepare = GameState_State_PenaltyBluePrepare;
  static const State PenaltyBlue = GameState_State_PenaltyBlue;
  static const State DirectBlue = GameState_State_DirectBlue;
  static const State IndirectBlue = GameState_State_IndirectBlue;
  static const State TimeoutYellow = GameState_State_TimeoutYellow;
  static const State TimeoutBlue = GameState_State_TimeoutBlue;
  static inline bool State_IsValid(int value) {
    return GameState_State_IsValid(value);
  }
  static const State State_MIN =
    GameState_State_State_MIN;
  static const State State_MAX =
    GameState_State_State_MAX;
  static const int State_ARRAYSIZE =
    GameState_State_State_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  State_descriptor() {
    return GameState_State_descriptor();
  }
  static inline const ::std::string& State_Name(State value) {
    return GameState_State_Name(value);
  }
  static inline bool State_Parse(const ::std::string& name,
      State* value) {
    return GameState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .SSL_Referee.Stage stage = 1;
  inline bool has_stage() const;
  inline void clear_stage();
  static const int kStageFieldNumber = 1;
  inline ::SSL_Referee_Stage stage() const;
  inline void set_stage(::SSL_Referee_Stage value);

  // optional sint32 stage_time_left = 2;
  inline bool has_stage_time_left() const;
  inline void clear_stage_time_left();
  static const int kStageTimeLeftFieldNumber = 2;
  inline ::google::protobuf::int32 stage_time_left() const;
  inline void set_stage_time_left(::google::protobuf::int32 value);

  // required .amun.GameState.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::amun::GameState_State state() const;
  inline void set_state(::amun::GameState_State value);

  // required .SSL_Referee.TeamInfo yellow = 4;
  inline bool has_yellow() const;
  inline void clear_yellow();
  static const int kYellowFieldNumber = 4;
  inline const ::SSL_Referee_TeamInfo& yellow() const;
  inline ::SSL_Referee_TeamInfo* mutable_yellow();
  inline ::SSL_Referee_TeamInfo* release_yellow();
  inline void set_allocated_yellow(::SSL_Referee_TeamInfo* yellow);

  // required .SSL_Referee.TeamInfo blue = 5;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 5;
  inline const ::SSL_Referee_TeamInfo& blue() const;
  inline ::SSL_Referee_TeamInfo* mutable_blue();
  inline ::SSL_Referee_TeamInfo* release_blue();
  inline void set_allocated_blue(::SSL_Referee_TeamInfo* blue);

  // @@protoc_insertion_point(class_scope:amun.GameState)
 private:
  inline void set_has_stage();
  inline void clear_has_stage();
  inline void set_has_stage_time_left();
  inline void clear_has_stage_time_left();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_yellow();
  inline void clear_has_yellow();
  inline void set_has_blue();
  inline void clear_has_blue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int stage_;
  ::google::protobuf::int32 stage_time_left_;
  ::SSL_Referee_TeamInfo* yellow_;
  ::SSL_Referee_TeamInfo* blue_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_gamestate_2eproto();
  friend void protobuf_AssignDesc_gamestate_2eproto();
  friend void protobuf_ShutdownFile_gamestate_2eproto();

  void InitAsDefaultInstance();
  static GameState* default_instance_;
};
// ===================================================================


// ===================================================================

// GameState

// required .SSL_Referee.Stage stage = 1;
inline bool GameState::has_stage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameState::set_has_stage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameState::clear_has_stage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameState::clear_stage() {
  stage_ = 0;
  clear_has_stage();
}
inline ::SSL_Referee_Stage GameState::stage() const {
  return static_cast< ::SSL_Referee_Stage >(stage_);
}
inline void GameState::set_stage(::SSL_Referee_Stage value) {
  assert(::SSL_Referee_Stage_IsValid(value));
  set_has_stage();
  stage_ = value;
}

// optional sint32 stage_time_left = 2;
inline bool GameState::has_stage_time_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameState::set_has_stage_time_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameState::clear_has_stage_time_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameState::clear_stage_time_left() {
  stage_time_left_ = 0;
  clear_has_stage_time_left();
}
inline ::google::protobuf::int32 GameState::stage_time_left() const {
  return stage_time_left_;
}
inline void GameState::set_stage_time_left(::google::protobuf::int32 value) {
  set_has_stage_time_left();
  stage_time_left_ = value;
}

// required .amun.GameState.State state = 3;
inline bool GameState::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameState::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameState::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameState::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::amun::GameState_State GameState::state() const {
  return static_cast< ::amun::GameState_State >(state_);
}
inline void GameState::set_state(::amun::GameState_State value) {
  assert(::amun::GameState_State_IsValid(value));
  set_has_state();
  state_ = value;
}

// required .SSL_Referee.TeamInfo yellow = 4;
inline bool GameState::has_yellow() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameState::set_has_yellow() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameState::clear_has_yellow() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameState::clear_yellow() {
  if (yellow_ != NULL) yellow_->::SSL_Referee_TeamInfo::Clear();
  clear_has_yellow();
}
inline const ::SSL_Referee_TeamInfo& GameState::yellow() const {
  return yellow_ != NULL ? *yellow_ : *default_instance_->yellow_;
}
inline ::SSL_Referee_TeamInfo* GameState::mutable_yellow() {
  set_has_yellow();
  if (yellow_ == NULL) yellow_ = new ::SSL_Referee_TeamInfo;
  return yellow_;
}
inline ::SSL_Referee_TeamInfo* GameState::release_yellow() {
  clear_has_yellow();
  ::SSL_Referee_TeamInfo* temp = yellow_;
  yellow_ = NULL;
  return temp;
}
inline void GameState::set_allocated_yellow(::SSL_Referee_TeamInfo* yellow) {
  delete yellow_;
  yellow_ = yellow;
  if (yellow) {
    set_has_yellow();
  } else {
    clear_has_yellow();
  }
}

// required .SSL_Referee.TeamInfo blue = 5;
inline bool GameState::has_blue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameState::set_has_blue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameState::clear_has_blue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameState::clear_blue() {
  if (blue_ != NULL) blue_->::SSL_Referee_TeamInfo::Clear();
  clear_has_blue();
}
inline const ::SSL_Referee_TeamInfo& GameState::blue() const {
  return blue_ != NULL ? *blue_ : *default_instance_->blue_;
}
inline ::SSL_Referee_TeamInfo* GameState::mutable_blue() {
  set_has_blue();
  if (blue_ == NULL) blue_ = new ::SSL_Referee_TeamInfo;
  return blue_;
}
inline ::SSL_Referee_TeamInfo* GameState::release_blue() {
  clear_has_blue();
  ::SSL_Referee_TeamInfo* temp = blue_;
  blue_ = NULL;
  return temp;
}
inline void GameState::set_allocated_blue(::SSL_Referee_TeamInfo* blue) {
  delete blue_;
  blue_ = blue;
  if (blue) {
    set_has_blue();
  } else {
    clear_has_blue();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace amun

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::GameState_State>() {
  return ::amun::GameState_State_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gamestate_2eproto__INCLUDED
