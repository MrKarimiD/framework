// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: world.proto

#ifndef PROTOBUF_world_2eproto__INCLUDED
#define PROTOBUF_world_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "robot.pb.h"
// @@protoc_insertion_point(includes)

namespace world {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_world_2eproto();
void protobuf_AssignDesc_world_2eproto();
void protobuf_ShutdownFile_world_2eproto();

class Geometry;
class BallPosition;
class Ball;
class RobotPosition;
class Robot;
class State;

// ===================================================================

class Geometry : public ::google::protobuf::Message {
 public:
  Geometry();
  virtual ~Geometry();

  Geometry(const Geometry& from);

  inline Geometry& operator=(const Geometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Geometry& default_instance();

  void Swap(Geometry* other);

  // implements Message ----------------------------------------------

  Geometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Geometry& from);
  void MergeFrom(const Geometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float line_width = 1;
  inline bool has_line_width() const;
  inline void clear_line_width();
  static const int kLineWidthFieldNumber = 1;
  inline float line_width() const;
  inline void set_line_width(float value);

  // required float field_width = 2;
  inline bool has_field_width() const;
  inline void clear_field_width();
  static const int kFieldWidthFieldNumber = 2;
  inline float field_width() const;
  inline void set_field_width(float value);

  // required float field_height = 3;
  inline bool has_field_height() const;
  inline void clear_field_height();
  static const int kFieldHeightFieldNumber = 3;
  inline float field_height() const;
  inline void set_field_height(float value);

  // required float boundary_width = 4;
  inline bool has_boundary_width() const;
  inline void clear_boundary_width();
  static const int kBoundaryWidthFieldNumber = 4;
  inline float boundary_width() const;
  inline void set_boundary_width(float value);

  // required float referee_width = 5;
  inline bool has_referee_width() const;
  inline void clear_referee_width();
  static const int kRefereeWidthFieldNumber = 5;
  inline float referee_width() const;
  inline void set_referee_width(float value);

  // required float goal_width = 6;
  inline bool has_goal_width() const;
  inline void clear_goal_width();
  static const int kGoalWidthFieldNumber = 6;
  inline float goal_width() const;
  inline void set_goal_width(float value);

  // required float goal_depth = 7;
  inline bool has_goal_depth() const;
  inline void clear_goal_depth();
  static const int kGoalDepthFieldNumber = 7;
  inline float goal_depth() const;
  inline void set_goal_depth(float value);

  // required float goal_wall_width = 8;
  inline bool has_goal_wall_width() const;
  inline void clear_goal_wall_width();
  static const int kGoalWallWidthFieldNumber = 8;
  inline float goal_wall_width() const;
  inline void set_goal_wall_width(float value);

  // required float center_circle_radius = 9;
  inline bool has_center_circle_radius() const;
  inline void clear_center_circle_radius();
  static const int kCenterCircleRadiusFieldNumber = 9;
  inline float center_circle_radius() const;
  inline void set_center_circle_radius(float value);

  // required float defense_radius = 10;
  inline bool has_defense_radius() const;
  inline void clear_defense_radius();
  static const int kDefenseRadiusFieldNumber = 10;
  inline float defense_radius() const;
  inline void set_defense_radius(float value);

  // required float defense_stretch = 11;
  inline bool has_defense_stretch() const;
  inline void clear_defense_stretch();
  static const int kDefenseStretchFieldNumber = 11;
  inline float defense_stretch() const;
  inline void set_defense_stretch(float value);

  // required float free_kick_from_defense_dist = 12;
  inline bool has_free_kick_from_defense_dist() const;
  inline void clear_free_kick_from_defense_dist();
  static const int kFreeKickFromDefenseDistFieldNumber = 12;
  inline float free_kick_from_defense_dist() const;
  inline void set_free_kick_from_defense_dist(float value);

  // required float penalty_spot_from_field_line_dist = 13;
  inline bool has_penalty_spot_from_field_line_dist() const;
  inline void clear_penalty_spot_from_field_line_dist();
  static const int kPenaltySpotFromFieldLineDistFieldNumber = 13;
  inline float penalty_spot_from_field_line_dist() const;
  inline void set_penalty_spot_from_field_line_dist(float value);

  // required float penalty_line_from_spot_dist = 14;
  inline bool has_penalty_line_from_spot_dist() const;
  inline void clear_penalty_line_from_spot_dist();
  static const int kPenaltyLineFromSpotDistFieldNumber = 14;
  inline float penalty_line_from_spot_dist() const;
  inline void set_penalty_line_from_spot_dist(float value);

  // required float goal_height = 15;
  inline bool has_goal_height() const;
  inline void clear_goal_height();
  static const int kGoalHeightFieldNumber = 15;
  inline float goal_height() const;
  inline void set_goal_height(float value);

  // @@protoc_insertion_point(class_scope:world.Geometry)
 private:
  inline void set_has_line_width();
  inline void clear_has_line_width();
  inline void set_has_field_width();
  inline void clear_has_field_width();
  inline void set_has_field_height();
  inline void clear_has_field_height();
  inline void set_has_boundary_width();
  inline void clear_has_boundary_width();
  inline void set_has_referee_width();
  inline void clear_has_referee_width();
  inline void set_has_goal_width();
  inline void clear_has_goal_width();
  inline void set_has_goal_depth();
  inline void clear_has_goal_depth();
  inline void set_has_goal_wall_width();
  inline void clear_has_goal_wall_width();
  inline void set_has_center_circle_radius();
  inline void clear_has_center_circle_radius();
  inline void set_has_defense_radius();
  inline void clear_has_defense_radius();
  inline void set_has_defense_stretch();
  inline void clear_has_defense_stretch();
  inline void set_has_free_kick_from_defense_dist();
  inline void clear_has_free_kick_from_defense_dist();
  inline void set_has_penalty_spot_from_field_line_dist();
  inline void clear_has_penalty_spot_from_field_line_dist();
  inline void set_has_penalty_line_from_spot_dist();
  inline void clear_has_penalty_line_from_spot_dist();
  inline void set_has_goal_height();
  inline void clear_has_goal_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float line_width_;
  float field_width_;
  float field_height_;
  float boundary_width_;
  float referee_width_;
  float goal_width_;
  float goal_depth_;
  float goal_wall_width_;
  float center_circle_radius_;
  float defense_radius_;
  float defense_stretch_;
  float free_kick_from_defense_dist_;
  float penalty_spot_from_field_line_dist_;
  float penalty_line_from_spot_dist_;
  float goal_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static Geometry* default_instance_;
};
// -------------------------------------------------------------------

class BallPosition : public ::google::protobuf::Message {
 public:
  BallPosition();
  virtual ~BallPosition();

  BallPosition(const BallPosition& from);

  inline BallPosition& operator=(const BallPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallPosition& default_instance();

  void Swap(BallPosition* other);

  // implements Message ----------------------------------------------

  BallPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallPosition& from);
  void MergeFrom(const BallPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required float p_x = 2;
  inline bool has_p_x() const;
  inline void clear_p_x();
  static const int kPXFieldNumber = 2;
  inline float p_x() const;
  inline void set_p_x(float value);

  // required float p_y = 3;
  inline bool has_p_y() const;
  inline void clear_p_y();
  static const int kPYFieldNumber = 3;
  inline float p_y() const;
  inline void set_p_y(float value);

  // optional float v_x = 5;
  inline bool has_v_x() const;
  inline void clear_v_x();
  static const int kVXFieldNumber = 5;
  inline float v_x() const;
  inline void set_v_x(float value);

  // optional float v_y = 6;
  inline bool has_v_y() const;
  inline void clear_v_y();
  static const int kVYFieldNumber = 6;
  inline float v_y() const;
  inline void set_v_y(float value);

  // optional float system_delay = 7;
  inline bool has_system_delay() const;
  inline void clear_system_delay();
  static const int kSystemDelayFieldNumber = 7;
  inline float system_delay() const;
  inline void set_system_delay(float value);

  // optional float time_diff_scaled = 8;
  inline bool has_time_diff_scaled() const;
  inline void clear_time_diff_scaled();
  static const int kTimeDiffScaledFieldNumber = 8;
  inline float time_diff_scaled() const;
  inline void set_time_diff_scaled(float value);

  // @@protoc_insertion_point(class_scope:world.BallPosition)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_p_x();
  inline void clear_has_p_x();
  inline void set_has_p_y();
  inline void clear_has_p_y();
  inline void set_has_v_x();
  inline void clear_has_v_x();
  inline void set_has_v_y();
  inline void clear_has_v_y();
  inline void set_has_system_delay();
  inline void clear_has_system_delay();
  inline void set_has_time_diff_scaled();
  inline void clear_has_time_diff_scaled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  float p_x_;
  float p_y_;
  float v_x_;
  float v_y_;
  float system_delay_;
  float time_diff_scaled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static BallPosition* default_instance_;
};
// -------------------------------------------------------------------

class Ball : public ::google::protobuf::Message {
 public:
  Ball();
  virtual ~Ball();

  Ball(const Ball& from);

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Ball& default_instance();

  void Swap(Ball* other);

  // implements Message ----------------------------------------------

  Ball* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Ball& from);
  void MergeFrom(const Ball& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float p_x = 1;
  inline bool has_p_x() const;
  inline void clear_p_x();
  static const int kPXFieldNumber = 1;
  inline float p_x() const;
  inline void set_p_x(float value);

  // required float p_y = 2;
  inline bool has_p_y() const;
  inline void clear_p_y();
  static const int kPYFieldNumber = 2;
  inline float p_y() const;
  inline void set_p_y(float value);

  // required float v_x = 3;
  inline bool has_v_x() const;
  inline void clear_v_x();
  static const int kVXFieldNumber = 3;
  inline float v_x() const;
  inline void set_v_x(float value);

  // required float v_y = 4;
  inline bool has_v_y() const;
  inline void clear_v_y();
  static const int kVYFieldNumber = 4;
  inline float v_y() const;
  inline void set_v_y(float value);

  // repeated .world.BallPosition raw = 5;
  inline int raw_size() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 5;
  inline const ::world::BallPosition& raw(int index) const;
  inline ::world::BallPosition* mutable_raw(int index);
  inline ::world::BallPosition* add_raw();
  inline const ::google::protobuf::RepeatedPtrField< ::world::BallPosition >&
      raw() const;
  inline ::google::protobuf::RepeatedPtrField< ::world::BallPosition >*
      mutable_raw();

  // @@protoc_insertion_point(class_scope:world.Ball)
 private:
  inline void set_has_p_x();
  inline void clear_has_p_x();
  inline void set_has_p_y();
  inline void clear_has_p_y();
  inline void set_has_v_x();
  inline void clear_has_v_x();
  inline void set_has_v_y();
  inline void clear_has_v_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float p_x_;
  float p_y_;
  float v_x_;
  float v_y_;
  ::google::protobuf::RepeatedPtrField< ::world::BallPosition > raw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static Ball* default_instance_;
};
// -------------------------------------------------------------------

class RobotPosition : public ::google::protobuf::Message {
 public:
  RobotPosition();
  virtual ~RobotPosition();

  RobotPosition(const RobotPosition& from);

  inline RobotPosition& operator=(const RobotPosition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RobotPosition& default_instance();

  void Swap(RobotPosition* other);

  // implements Message ----------------------------------------------

  RobotPosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RobotPosition& from);
  void MergeFrom(const RobotPosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required float p_x = 2;
  inline bool has_p_x() const;
  inline void clear_p_x();
  static const int kPXFieldNumber = 2;
  inline float p_x() const;
  inline void set_p_x(float value);

  // required float p_y = 3;
  inline bool has_p_y() const;
  inline void clear_p_y();
  static const int kPYFieldNumber = 3;
  inline float p_y() const;
  inline void set_p_y(float value);

  // required float phi = 4;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline float phi() const;
  inline void set_phi(float value);

  // optional float v_x = 5;
  inline bool has_v_x() const;
  inline void clear_v_x();
  static const int kVXFieldNumber = 5;
  inline float v_x() const;
  inline void set_v_x(float value);

  // optional float v_y = 6;
  inline bool has_v_y() const;
  inline void clear_v_y();
  static const int kVYFieldNumber = 6;
  inline float v_y() const;
  inline void set_v_y(float value);

  // optional float system_delay = 7;
  inline bool has_system_delay() const;
  inline void clear_system_delay();
  static const int kSystemDelayFieldNumber = 7;
  inline float system_delay() const;
  inline void set_system_delay(float value);

  // optional float time_diff_scaled = 8;
  inline bool has_time_diff_scaled() const;
  inline void clear_time_diff_scaled();
  static const int kTimeDiffScaledFieldNumber = 8;
  inline float time_diff_scaled() const;
  inline void set_time_diff_scaled(float value);

  // optional float omega = 9;
  inline bool has_omega() const;
  inline void clear_omega();
  static const int kOmegaFieldNumber = 9;
  inline float omega() const;
  inline void set_omega(float value);

  // @@protoc_insertion_point(class_scope:world.RobotPosition)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_p_x();
  inline void clear_has_p_x();
  inline void set_has_p_y();
  inline void clear_has_p_y();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_v_x();
  inline void clear_has_v_x();
  inline void set_has_v_y();
  inline void clear_has_v_y();
  inline void set_has_system_delay();
  inline void clear_has_system_delay();
  inline void set_has_time_diff_scaled();
  inline void clear_has_time_diff_scaled();
  inline void set_has_omega();
  inline void clear_has_omega();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  float p_x_;
  float p_y_;
  float phi_;
  float v_x_;
  float v_y_;
  float system_delay_;
  float time_diff_scaled_;
  float omega_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static RobotPosition* default_instance_;
};
// -------------------------------------------------------------------

class Robot : public ::google::protobuf::Message {
 public:
  Robot();
  virtual ~Robot();

  Robot(const Robot& from);

  inline Robot& operator=(const Robot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Robot& default_instance();

  void Swap(Robot* other);

  // implements Message ----------------------------------------------

  Robot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Robot& from);
  void MergeFrom(const Robot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required float p_x = 2;
  inline bool has_p_x() const;
  inline void clear_p_x();
  static const int kPXFieldNumber = 2;
  inline float p_x() const;
  inline void set_p_x(float value);

  // required float p_y = 3;
  inline bool has_p_y() const;
  inline void clear_p_y();
  static const int kPYFieldNumber = 3;
  inline float p_y() const;
  inline void set_p_y(float value);

  // required float phi = 4;
  inline bool has_phi() const;
  inline void clear_phi();
  static const int kPhiFieldNumber = 4;
  inline float phi() const;
  inline void set_phi(float value);

  // required float v_x = 5;
  inline bool has_v_x() const;
  inline void clear_v_x();
  static const int kVXFieldNumber = 5;
  inline float v_x() const;
  inline void set_v_x(float value);

  // required float v_y = 6;
  inline bool has_v_y() const;
  inline void clear_v_y();
  static const int kVYFieldNumber = 6;
  inline float v_y() const;
  inline void set_v_y(float value);

  // required float omega = 7;
  inline bool has_omega() const;
  inline void clear_omega();
  static const int kOmegaFieldNumber = 7;
  inline float omega() const;
  inline void set_omega(float value);

  // repeated .world.RobotPosition raw = 8;
  inline int raw_size() const;
  inline void clear_raw();
  static const int kRawFieldNumber = 8;
  inline const ::world::RobotPosition& raw(int index) const;
  inline ::world::RobotPosition* mutable_raw(int index);
  inline ::world::RobotPosition* add_raw();
  inline const ::google::protobuf::RepeatedPtrField< ::world::RobotPosition >&
      raw() const;
  inline ::google::protobuf::RepeatedPtrField< ::world::RobotPosition >*
      mutable_raw();

  // @@protoc_insertion_point(class_scope:world.Robot)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_p_x();
  inline void clear_has_p_x();
  inline void set_has_p_y();
  inline void clear_has_p_y();
  inline void set_has_phi();
  inline void clear_has_phi();
  inline void set_has_v_x();
  inline void clear_has_v_x();
  inline void set_has_v_y();
  inline void clear_has_v_y();
  inline void set_has_omega();
  inline void clear_has_omega();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 id_;
  float p_x_;
  float p_y_;
  float phi_;
  float v_x_;
  float v_y_;
  ::google::protobuf::RepeatedPtrField< ::world::RobotPosition > raw_;
  float omega_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static Robot* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional .world.Ball ball = 2;
  inline bool has_ball() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 2;
  inline const ::world::Ball& ball() const;
  inline ::world::Ball* mutable_ball();
  inline ::world::Ball* release_ball();
  inline void set_allocated_ball(::world::Ball* ball);

  // repeated .world.Robot yellow = 3;
  inline int yellow_size() const;
  inline void clear_yellow();
  static const int kYellowFieldNumber = 3;
  inline const ::world::Robot& yellow(int index) const;
  inline ::world::Robot* mutable_yellow(int index);
  inline ::world::Robot* add_yellow();
  inline const ::google::protobuf::RepeatedPtrField< ::world::Robot >&
      yellow() const;
  inline ::google::protobuf::RepeatedPtrField< ::world::Robot >*
      mutable_yellow();

  // repeated .world.Robot blue = 4;
  inline int blue_size() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 4;
  inline const ::world::Robot& blue(int index) const;
  inline ::world::Robot* mutable_blue(int index);
  inline ::world::Robot* add_blue();
  inline const ::google::protobuf::RepeatedPtrField< ::world::Robot >&
      blue() const;
  inline ::google::protobuf::RepeatedPtrField< ::world::Robot >*
      mutable_blue();

  // repeated .robot.RadioResponse radio_response = 5;
  inline int radio_response_size() const;
  inline void clear_radio_response();
  static const int kRadioResponseFieldNumber = 5;
  inline const ::robot::RadioResponse& radio_response(int index) const;
  inline ::robot::RadioResponse* mutable_radio_response(int index);
  inline ::robot::RadioResponse* add_radio_response();
  inline const ::google::protobuf::RepeatedPtrField< ::robot::RadioResponse >&
      radio_response() const;
  inline ::google::protobuf::RepeatedPtrField< ::robot::RadioResponse >*
      mutable_radio_response();

  // optional bool is_simulated = 6;
  inline bool has_is_simulated() const;
  inline void clear_is_simulated();
  static const int kIsSimulatedFieldNumber = 6;
  inline bool is_simulated() const;
  inline void set_is_simulated(bool value);

  // optional bool has_vision_data = 7;
  inline bool has_has_vision_data() const;
  inline void clear_has_vision_data();
  static const int kHasVisionDataFieldNumber = 7;
  inline bool has_vision_data() const;
  inline void set_has_vision_data(bool value);

  // @@protoc_insertion_point(class_scope:world.State)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_ball();
  inline void clear_has_ball();
  inline void set_has_is_simulated();
  inline void clear_has_is_simulated();
  inline void set_has_has_vision_data();
  inline void clear_has_has_vision_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::world::Ball* ball_;
  ::google::protobuf::RepeatedPtrField< ::world::Robot > yellow_;
  ::google::protobuf::RepeatedPtrField< ::world::Robot > blue_;
  ::google::protobuf::RepeatedPtrField< ::robot::RadioResponse > radio_response_;
  bool is_simulated_;
  bool has_vision_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_world_2eproto();
  friend void protobuf_AssignDesc_world_2eproto();
  friend void protobuf_ShutdownFile_world_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// ===================================================================


// ===================================================================

// Geometry

// required float line_width = 1;
inline bool Geometry::has_line_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Geometry::set_has_line_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Geometry::clear_has_line_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Geometry::clear_line_width() {
  line_width_ = 0;
  clear_has_line_width();
}
inline float Geometry::line_width() const {
  return line_width_;
}
inline void Geometry::set_line_width(float value) {
  set_has_line_width();
  line_width_ = value;
}

// required float field_width = 2;
inline bool Geometry::has_field_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Geometry::set_has_field_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Geometry::clear_has_field_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Geometry::clear_field_width() {
  field_width_ = 0;
  clear_has_field_width();
}
inline float Geometry::field_width() const {
  return field_width_;
}
inline void Geometry::set_field_width(float value) {
  set_has_field_width();
  field_width_ = value;
}

// required float field_height = 3;
inline bool Geometry::has_field_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Geometry::set_has_field_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Geometry::clear_has_field_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Geometry::clear_field_height() {
  field_height_ = 0;
  clear_has_field_height();
}
inline float Geometry::field_height() const {
  return field_height_;
}
inline void Geometry::set_field_height(float value) {
  set_has_field_height();
  field_height_ = value;
}

// required float boundary_width = 4;
inline bool Geometry::has_boundary_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Geometry::set_has_boundary_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Geometry::clear_has_boundary_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Geometry::clear_boundary_width() {
  boundary_width_ = 0;
  clear_has_boundary_width();
}
inline float Geometry::boundary_width() const {
  return boundary_width_;
}
inline void Geometry::set_boundary_width(float value) {
  set_has_boundary_width();
  boundary_width_ = value;
}

// required float referee_width = 5;
inline bool Geometry::has_referee_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Geometry::set_has_referee_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Geometry::clear_has_referee_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Geometry::clear_referee_width() {
  referee_width_ = 0;
  clear_has_referee_width();
}
inline float Geometry::referee_width() const {
  return referee_width_;
}
inline void Geometry::set_referee_width(float value) {
  set_has_referee_width();
  referee_width_ = value;
}

// required float goal_width = 6;
inline bool Geometry::has_goal_width() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Geometry::set_has_goal_width() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Geometry::clear_has_goal_width() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Geometry::clear_goal_width() {
  goal_width_ = 0;
  clear_has_goal_width();
}
inline float Geometry::goal_width() const {
  return goal_width_;
}
inline void Geometry::set_goal_width(float value) {
  set_has_goal_width();
  goal_width_ = value;
}

// required float goal_depth = 7;
inline bool Geometry::has_goal_depth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Geometry::set_has_goal_depth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Geometry::clear_has_goal_depth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Geometry::clear_goal_depth() {
  goal_depth_ = 0;
  clear_has_goal_depth();
}
inline float Geometry::goal_depth() const {
  return goal_depth_;
}
inline void Geometry::set_goal_depth(float value) {
  set_has_goal_depth();
  goal_depth_ = value;
}

// required float goal_wall_width = 8;
inline bool Geometry::has_goal_wall_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Geometry::set_has_goal_wall_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Geometry::clear_has_goal_wall_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Geometry::clear_goal_wall_width() {
  goal_wall_width_ = 0;
  clear_has_goal_wall_width();
}
inline float Geometry::goal_wall_width() const {
  return goal_wall_width_;
}
inline void Geometry::set_goal_wall_width(float value) {
  set_has_goal_wall_width();
  goal_wall_width_ = value;
}

// required float center_circle_radius = 9;
inline bool Geometry::has_center_circle_radius() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Geometry::set_has_center_circle_radius() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Geometry::clear_has_center_circle_radius() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Geometry::clear_center_circle_radius() {
  center_circle_radius_ = 0;
  clear_has_center_circle_radius();
}
inline float Geometry::center_circle_radius() const {
  return center_circle_radius_;
}
inline void Geometry::set_center_circle_radius(float value) {
  set_has_center_circle_radius();
  center_circle_radius_ = value;
}

// required float defense_radius = 10;
inline bool Geometry::has_defense_radius() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Geometry::set_has_defense_radius() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Geometry::clear_has_defense_radius() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Geometry::clear_defense_radius() {
  defense_radius_ = 0;
  clear_has_defense_radius();
}
inline float Geometry::defense_radius() const {
  return defense_radius_;
}
inline void Geometry::set_defense_radius(float value) {
  set_has_defense_radius();
  defense_radius_ = value;
}

// required float defense_stretch = 11;
inline bool Geometry::has_defense_stretch() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Geometry::set_has_defense_stretch() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Geometry::clear_has_defense_stretch() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Geometry::clear_defense_stretch() {
  defense_stretch_ = 0;
  clear_has_defense_stretch();
}
inline float Geometry::defense_stretch() const {
  return defense_stretch_;
}
inline void Geometry::set_defense_stretch(float value) {
  set_has_defense_stretch();
  defense_stretch_ = value;
}

// required float free_kick_from_defense_dist = 12;
inline bool Geometry::has_free_kick_from_defense_dist() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Geometry::set_has_free_kick_from_defense_dist() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Geometry::clear_has_free_kick_from_defense_dist() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Geometry::clear_free_kick_from_defense_dist() {
  free_kick_from_defense_dist_ = 0;
  clear_has_free_kick_from_defense_dist();
}
inline float Geometry::free_kick_from_defense_dist() const {
  return free_kick_from_defense_dist_;
}
inline void Geometry::set_free_kick_from_defense_dist(float value) {
  set_has_free_kick_from_defense_dist();
  free_kick_from_defense_dist_ = value;
}

// required float penalty_spot_from_field_line_dist = 13;
inline bool Geometry::has_penalty_spot_from_field_line_dist() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Geometry::set_has_penalty_spot_from_field_line_dist() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Geometry::clear_has_penalty_spot_from_field_line_dist() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Geometry::clear_penalty_spot_from_field_line_dist() {
  penalty_spot_from_field_line_dist_ = 0;
  clear_has_penalty_spot_from_field_line_dist();
}
inline float Geometry::penalty_spot_from_field_line_dist() const {
  return penalty_spot_from_field_line_dist_;
}
inline void Geometry::set_penalty_spot_from_field_line_dist(float value) {
  set_has_penalty_spot_from_field_line_dist();
  penalty_spot_from_field_line_dist_ = value;
}

// required float penalty_line_from_spot_dist = 14;
inline bool Geometry::has_penalty_line_from_spot_dist() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Geometry::set_has_penalty_line_from_spot_dist() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Geometry::clear_has_penalty_line_from_spot_dist() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Geometry::clear_penalty_line_from_spot_dist() {
  penalty_line_from_spot_dist_ = 0;
  clear_has_penalty_line_from_spot_dist();
}
inline float Geometry::penalty_line_from_spot_dist() const {
  return penalty_line_from_spot_dist_;
}
inline void Geometry::set_penalty_line_from_spot_dist(float value) {
  set_has_penalty_line_from_spot_dist();
  penalty_line_from_spot_dist_ = value;
}

// required float goal_height = 15;
inline bool Geometry::has_goal_height() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Geometry::set_has_goal_height() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Geometry::clear_has_goal_height() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Geometry::clear_goal_height() {
  goal_height_ = 0;
  clear_has_goal_height();
}
inline float Geometry::goal_height() const {
  return goal_height_;
}
inline void Geometry::set_goal_height(float value) {
  set_has_goal_height();
  goal_height_ = value;
}

// -------------------------------------------------------------------

// BallPosition

// required int64 time = 1;
inline bool BallPosition::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallPosition::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallPosition::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallPosition::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 BallPosition::time() const {
  return time_;
}
inline void BallPosition::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required float p_x = 2;
inline bool BallPosition::has_p_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallPosition::set_has_p_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallPosition::clear_has_p_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallPosition::clear_p_x() {
  p_x_ = 0;
  clear_has_p_x();
}
inline float BallPosition::p_x() const {
  return p_x_;
}
inline void BallPosition::set_p_x(float value) {
  set_has_p_x();
  p_x_ = value;
}

// required float p_y = 3;
inline bool BallPosition::has_p_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallPosition::set_has_p_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallPosition::clear_has_p_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallPosition::clear_p_y() {
  p_y_ = 0;
  clear_has_p_y();
}
inline float BallPosition::p_y() const {
  return p_y_;
}
inline void BallPosition::set_p_y(float value) {
  set_has_p_y();
  p_y_ = value;
}

// optional float v_x = 5;
inline bool BallPosition::has_v_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallPosition::set_has_v_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallPosition::clear_has_v_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallPosition::clear_v_x() {
  v_x_ = 0;
  clear_has_v_x();
}
inline float BallPosition::v_x() const {
  return v_x_;
}
inline void BallPosition::set_v_x(float value) {
  set_has_v_x();
  v_x_ = value;
}

// optional float v_y = 6;
inline bool BallPosition::has_v_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BallPosition::set_has_v_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BallPosition::clear_has_v_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BallPosition::clear_v_y() {
  v_y_ = 0;
  clear_has_v_y();
}
inline float BallPosition::v_y() const {
  return v_y_;
}
inline void BallPosition::set_v_y(float value) {
  set_has_v_y();
  v_y_ = value;
}

// optional float system_delay = 7;
inline bool BallPosition::has_system_delay() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BallPosition::set_has_system_delay() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BallPosition::clear_has_system_delay() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BallPosition::clear_system_delay() {
  system_delay_ = 0;
  clear_has_system_delay();
}
inline float BallPosition::system_delay() const {
  return system_delay_;
}
inline void BallPosition::set_system_delay(float value) {
  set_has_system_delay();
  system_delay_ = value;
}

// optional float time_diff_scaled = 8;
inline bool BallPosition::has_time_diff_scaled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BallPosition::set_has_time_diff_scaled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BallPosition::clear_has_time_diff_scaled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BallPosition::clear_time_diff_scaled() {
  time_diff_scaled_ = 0;
  clear_has_time_diff_scaled();
}
inline float BallPosition::time_diff_scaled() const {
  return time_diff_scaled_;
}
inline void BallPosition::set_time_diff_scaled(float value) {
  set_has_time_diff_scaled();
  time_diff_scaled_ = value;
}

// -------------------------------------------------------------------

// Ball

// required float p_x = 1;
inline bool Ball::has_p_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Ball::set_has_p_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Ball::clear_has_p_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Ball::clear_p_x() {
  p_x_ = 0;
  clear_has_p_x();
}
inline float Ball::p_x() const {
  return p_x_;
}
inline void Ball::set_p_x(float value) {
  set_has_p_x();
  p_x_ = value;
}

// required float p_y = 2;
inline bool Ball::has_p_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Ball::set_has_p_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Ball::clear_has_p_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Ball::clear_p_y() {
  p_y_ = 0;
  clear_has_p_y();
}
inline float Ball::p_y() const {
  return p_y_;
}
inline void Ball::set_p_y(float value) {
  set_has_p_y();
  p_y_ = value;
}

// required float v_x = 3;
inline bool Ball::has_v_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Ball::set_has_v_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Ball::clear_has_v_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Ball::clear_v_x() {
  v_x_ = 0;
  clear_has_v_x();
}
inline float Ball::v_x() const {
  return v_x_;
}
inline void Ball::set_v_x(float value) {
  set_has_v_x();
  v_x_ = value;
}

// required float v_y = 4;
inline bool Ball::has_v_y() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Ball::set_has_v_y() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Ball::clear_has_v_y() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Ball::clear_v_y() {
  v_y_ = 0;
  clear_has_v_y();
}
inline float Ball::v_y() const {
  return v_y_;
}
inline void Ball::set_v_y(float value) {
  set_has_v_y();
  v_y_ = value;
}

// repeated .world.BallPosition raw = 5;
inline int Ball::raw_size() const {
  return raw_.size();
}
inline void Ball::clear_raw() {
  raw_.Clear();
}
inline const ::world::BallPosition& Ball::raw(int index) const {
  return raw_.Get(index);
}
inline ::world::BallPosition* Ball::mutable_raw(int index) {
  return raw_.Mutable(index);
}
inline ::world::BallPosition* Ball::add_raw() {
  return raw_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::world::BallPosition >&
Ball::raw() const {
  return raw_;
}
inline ::google::protobuf::RepeatedPtrField< ::world::BallPosition >*
Ball::mutable_raw() {
  return &raw_;
}

// -------------------------------------------------------------------

// RobotPosition

// required int64 time = 1;
inline bool RobotPosition::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RobotPosition::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RobotPosition::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RobotPosition::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 RobotPosition::time() const {
  return time_;
}
inline void RobotPosition::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required float p_x = 2;
inline bool RobotPosition::has_p_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RobotPosition::set_has_p_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RobotPosition::clear_has_p_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RobotPosition::clear_p_x() {
  p_x_ = 0;
  clear_has_p_x();
}
inline float RobotPosition::p_x() const {
  return p_x_;
}
inline void RobotPosition::set_p_x(float value) {
  set_has_p_x();
  p_x_ = value;
}

// required float p_y = 3;
inline bool RobotPosition::has_p_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RobotPosition::set_has_p_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RobotPosition::clear_has_p_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RobotPosition::clear_p_y() {
  p_y_ = 0;
  clear_has_p_y();
}
inline float RobotPosition::p_y() const {
  return p_y_;
}
inline void RobotPosition::set_p_y(float value) {
  set_has_p_y();
  p_y_ = value;
}

// required float phi = 4;
inline bool RobotPosition::has_phi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RobotPosition::set_has_phi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RobotPosition::clear_has_phi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RobotPosition::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline float RobotPosition::phi() const {
  return phi_;
}
inline void RobotPosition::set_phi(float value) {
  set_has_phi();
  phi_ = value;
}

// optional float v_x = 5;
inline bool RobotPosition::has_v_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RobotPosition::set_has_v_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RobotPosition::clear_has_v_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RobotPosition::clear_v_x() {
  v_x_ = 0;
  clear_has_v_x();
}
inline float RobotPosition::v_x() const {
  return v_x_;
}
inline void RobotPosition::set_v_x(float value) {
  set_has_v_x();
  v_x_ = value;
}

// optional float v_y = 6;
inline bool RobotPosition::has_v_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RobotPosition::set_has_v_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RobotPosition::clear_has_v_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RobotPosition::clear_v_y() {
  v_y_ = 0;
  clear_has_v_y();
}
inline float RobotPosition::v_y() const {
  return v_y_;
}
inline void RobotPosition::set_v_y(float value) {
  set_has_v_y();
  v_y_ = value;
}

// optional float system_delay = 7;
inline bool RobotPosition::has_system_delay() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RobotPosition::set_has_system_delay() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RobotPosition::clear_has_system_delay() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RobotPosition::clear_system_delay() {
  system_delay_ = 0;
  clear_has_system_delay();
}
inline float RobotPosition::system_delay() const {
  return system_delay_;
}
inline void RobotPosition::set_system_delay(float value) {
  set_has_system_delay();
  system_delay_ = value;
}

// optional float time_diff_scaled = 8;
inline bool RobotPosition::has_time_diff_scaled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RobotPosition::set_has_time_diff_scaled() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RobotPosition::clear_has_time_diff_scaled() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RobotPosition::clear_time_diff_scaled() {
  time_diff_scaled_ = 0;
  clear_has_time_diff_scaled();
}
inline float RobotPosition::time_diff_scaled() const {
  return time_diff_scaled_;
}
inline void RobotPosition::set_time_diff_scaled(float value) {
  set_has_time_diff_scaled();
  time_diff_scaled_ = value;
}

// optional float omega = 9;
inline bool RobotPosition::has_omega() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RobotPosition::set_has_omega() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RobotPosition::clear_has_omega() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RobotPosition::clear_omega() {
  omega_ = 0;
  clear_has_omega();
}
inline float RobotPosition::omega() const {
  return omega_;
}
inline void RobotPosition::set_omega(float value) {
  set_has_omega();
  omega_ = value;
}

// -------------------------------------------------------------------

// Robot

// required uint32 id = 1;
inline bool Robot::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Robot::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Robot::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Robot::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Robot::id() const {
  return id_;
}
inline void Robot::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required float p_x = 2;
inline bool Robot::has_p_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Robot::set_has_p_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Robot::clear_has_p_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Robot::clear_p_x() {
  p_x_ = 0;
  clear_has_p_x();
}
inline float Robot::p_x() const {
  return p_x_;
}
inline void Robot::set_p_x(float value) {
  set_has_p_x();
  p_x_ = value;
}

// required float p_y = 3;
inline bool Robot::has_p_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Robot::set_has_p_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Robot::clear_has_p_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Robot::clear_p_y() {
  p_y_ = 0;
  clear_has_p_y();
}
inline float Robot::p_y() const {
  return p_y_;
}
inline void Robot::set_p_y(float value) {
  set_has_p_y();
  p_y_ = value;
}

// required float phi = 4;
inline bool Robot::has_phi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Robot::set_has_phi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Robot::clear_has_phi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Robot::clear_phi() {
  phi_ = 0;
  clear_has_phi();
}
inline float Robot::phi() const {
  return phi_;
}
inline void Robot::set_phi(float value) {
  set_has_phi();
  phi_ = value;
}

// required float v_x = 5;
inline bool Robot::has_v_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Robot::set_has_v_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Robot::clear_has_v_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Robot::clear_v_x() {
  v_x_ = 0;
  clear_has_v_x();
}
inline float Robot::v_x() const {
  return v_x_;
}
inline void Robot::set_v_x(float value) {
  set_has_v_x();
  v_x_ = value;
}

// required float v_y = 6;
inline bool Robot::has_v_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Robot::set_has_v_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Robot::clear_has_v_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Robot::clear_v_y() {
  v_y_ = 0;
  clear_has_v_y();
}
inline float Robot::v_y() const {
  return v_y_;
}
inline void Robot::set_v_y(float value) {
  set_has_v_y();
  v_y_ = value;
}

// required float omega = 7;
inline bool Robot::has_omega() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Robot::set_has_omega() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Robot::clear_has_omega() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Robot::clear_omega() {
  omega_ = 0;
  clear_has_omega();
}
inline float Robot::omega() const {
  return omega_;
}
inline void Robot::set_omega(float value) {
  set_has_omega();
  omega_ = value;
}

// repeated .world.RobotPosition raw = 8;
inline int Robot::raw_size() const {
  return raw_.size();
}
inline void Robot::clear_raw() {
  raw_.Clear();
}
inline const ::world::RobotPosition& Robot::raw(int index) const {
  return raw_.Get(index);
}
inline ::world::RobotPosition* Robot::mutable_raw(int index) {
  return raw_.Mutable(index);
}
inline ::world::RobotPosition* Robot::add_raw() {
  return raw_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::world::RobotPosition >&
Robot::raw() const {
  return raw_;
}
inline ::google::protobuf::RepeatedPtrField< ::world::RobotPosition >*
Robot::mutable_raw() {
  return &raw_;
}

// -------------------------------------------------------------------

// State

// required int64 time = 1;
inline bool State::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 State::time() const {
  return time_;
}
inline void State::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional .world.Ball ball = 2;
inline bool State::has_ball() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_ball() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_ball() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_ball() {
  if (ball_ != NULL) ball_->::world::Ball::Clear();
  clear_has_ball();
}
inline const ::world::Ball& State::ball() const {
  return ball_ != NULL ? *ball_ : *default_instance_->ball_;
}
inline ::world::Ball* State::mutable_ball() {
  set_has_ball();
  if (ball_ == NULL) ball_ = new ::world::Ball;
  return ball_;
}
inline ::world::Ball* State::release_ball() {
  clear_has_ball();
  ::world::Ball* temp = ball_;
  ball_ = NULL;
  return temp;
}
inline void State::set_allocated_ball(::world::Ball* ball) {
  delete ball_;
  ball_ = ball;
  if (ball) {
    set_has_ball();
  } else {
    clear_has_ball();
  }
}

// repeated .world.Robot yellow = 3;
inline int State::yellow_size() const {
  return yellow_.size();
}
inline void State::clear_yellow() {
  yellow_.Clear();
}
inline const ::world::Robot& State::yellow(int index) const {
  return yellow_.Get(index);
}
inline ::world::Robot* State::mutable_yellow(int index) {
  return yellow_.Mutable(index);
}
inline ::world::Robot* State::add_yellow() {
  return yellow_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::world::Robot >&
State::yellow() const {
  return yellow_;
}
inline ::google::protobuf::RepeatedPtrField< ::world::Robot >*
State::mutable_yellow() {
  return &yellow_;
}

// repeated .world.Robot blue = 4;
inline int State::blue_size() const {
  return blue_.size();
}
inline void State::clear_blue() {
  blue_.Clear();
}
inline const ::world::Robot& State::blue(int index) const {
  return blue_.Get(index);
}
inline ::world::Robot* State::mutable_blue(int index) {
  return blue_.Mutable(index);
}
inline ::world::Robot* State::add_blue() {
  return blue_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::world::Robot >&
State::blue() const {
  return blue_;
}
inline ::google::protobuf::RepeatedPtrField< ::world::Robot >*
State::mutable_blue() {
  return &blue_;
}

// repeated .robot.RadioResponse radio_response = 5;
inline int State::radio_response_size() const {
  return radio_response_.size();
}
inline void State::clear_radio_response() {
  radio_response_.Clear();
}
inline const ::robot::RadioResponse& State::radio_response(int index) const {
  return radio_response_.Get(index);
}
inline ::robot::RadioResponse* State::mutable_radio_response(int index) {
  return radio_response_.Mutable(index);
}
inline ::robot::RadioResponse* State::add_radio_response() {
  return radio_response_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robot::RadioResponse >&
State::radio_response() const {
  return radio_response_;
}
inline ::google::protobuf::RepeatedPtrField< ::robot::RadioResponse >*
State::mutable_radio_response() {
  return &radio_response_;
}

// optional bool is_simulated = 6;
inline bool State::has_is_simulated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_is_simulated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_is_simulated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void State::clear_is_simulated() {
  is_simulated_ = false;
  clear_has_is_simulated();
}
inline bool State::is_simulated() const {
  return is_simulated_;
}
inline void State::set_is_simulated(bool value) {
  set_has_is_simulated();
  is_simulated_ = value;
}

// optional bool has_vision_data = 7;
inline bool State::has_has_vision_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void State::set_has_has_vision_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void State::clear_has_has_vision_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void State::clear_has_vision_data() {
  has_vision_data_ = false;
  clear_has_has_vision_data();
}
inline bool State::has_vision_data() const {
  return has_vision_data_;
}
inline void State::set_has_vision_data(bool value) {
  set_has_has_vision_data();
  has_vision_data_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace world

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_world_2eproto__INCLUDED
