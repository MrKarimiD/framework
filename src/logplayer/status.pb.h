// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: status.proto

#ifndef PROTOBUF_status_2eproto__INCLUDED
#define PROTOBUF_status_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "debug.pb.h"
#include "gamestate.pb.h"
#include "robot.pb.h"
#include "world.pb.h"
#include "userinput.pb.h"
// @@protoc_insertion_point(includes)

namespace amun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_status_2eproto();
void protobuf_AssignDesc_status_2eproto();
void protobuf_ShutdownFile_status_2eproto();

class StatusStrategy;
class Timing;
class StatusTransceiver;
class PortBindError;
class StatusAmun;
class Status;

enum StatusStrategy_STATE {
  StatusStrategy_STATE_CLOSED = 1,
  StatusStrategy_STATE_RUNNING = 3,
  StatusStrategy_STATE_FAILED = 4
};
bool StatusStrategy_STATE_IsValid(int value);
const StatusStrategy_STATE StatusStrategy_STATE_STATE_MIN = StatusStrategy_STATE_CLOSED;
const StatusStrategy_STATE StatusStrategy_STATE_STATE_MAX = StatusStrategy_STATE_FAILED;
const int StatusStrategy_STATE_STATE_ARRAYSIZE = StatusStrategy_STATE_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusStrategy_STATE_descriptor();
inline const ::std::string& StatusStrategy_STATE_Name(StatusStrategy_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusStrategy_STATE_descriptor(), value);
}
inline bool StatusStrategy_STATE_Parse(
    const ::std::string& name, StatusStrategy_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusStrategy_STATE>(
    StatusStrategy_STATE_descriptor(), name, value);
}
// ===================================================================

class StatusStrategy : public ::google::protobuf::Message {
 public:
  StatusStrategy();
  virtual ~StatusStrategy();

  StatusStrategy(const StatusStrategy& from);

  inline StatusStrategy& operator=(const StatusStrategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusStrategy& default_instance();

  void Swap(StatusStrategy* other);

  // implements Message ----------------------------------------------

  StatusStrategy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusStrategy& from);
  void MergeFrom(const StatusStrategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StatusStrategy_STATE STATE;
  static const STATE CLOSED = StatusStrategy_STATE_CLOSED;
  static const STATE RUNNING = StatusStrategy_STATE_RUNNING;
  static const STATE FAILED = StatusStrategy_STATE_FAILED;
  static inline bool STATE_IsValid(int value) {
    return StatusStrategy_STATE_IsValid(value);
  }
  static const STATE STATE_MIN =
    StatusStrategy_STATE_STATE_MIN;
  static const STATE STATE_MAX =
    StatusStrategy_STATE_STATE_MAX;
  static const int STATE_ARRAYSIZE =
    StatusStrategy_STATE_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  STATE_descriptor() {
    return StatusStrategy_STATE_descriptor();
  }
  static inline const ::std::string& STATE_Name(STATE value) {
    return StatusStrategy_STATE_Name(value);
  }
  static inline bool STATE_Parse(const ::std::string& name,
      STATE* value) {
    return StatusStrategy_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .amun.StatusStrategy.STATE state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::amun::StatusStrategy_STATE state() const;
  inline void set_state(::amun::StatusStrategy_STATE value);

  // optional string filename = 2;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string current_entry_point = 4;
  inline bool has_current_entry_point() const;
  inline void clear_current_entry_point();
  static const int kCurrentEntryPointFieldNumber = 4;
  inline const ::std::string& current_entry_point() const;
  inline void set_current_entry_point(const ::std::string& value);
  inline void set_current_entry_point(const char* value);
  inline void set_current_entry_point(const char* value, size_t size);
  inline ::std::string* mutable_current_entry_point();
  inline ::std::string* release_current_entry_point();
  inline void set_allocated_current_entry_point(::std::string* current_entry_point);

  // repeated string entry_point = 5;
  inline int entry_point_size() const;
  inline void clear_entry_point();
  static const int kEntryPointFieldNumber = 5;
  inline const ::std::string& entry_point(int index) const;
  inline ::std::string* mutable_entry_point(int index);
  inline void set_entry_point(int index, const ::std::string& value);
  inline void set_entry_point(int index, const char* value);
  inline void set_entry_point(int index, const char* value, size_t size);
  inline ::std::string* add_entry_point();
  inline void add_entry_point(const ::std::string& value);
  inline void add_entry_point(const char* value);
  inline void add_entry_point(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& entry_point() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_entry_point();

  // @@protoc_insertion_point(class_scope:amun.StatusStrategy)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_current_entry_point();
  inline void clear_has_current_entry_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::std::string* name_;
  ::std::string* current_entry_point_;
  ::google::protobuf::RepeatedPtrField< ::std::string> entry_point_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static StatusStrategy* default_instance_;
};
// -------------------------------------------------------------------

class Timing : public ::google::protobuf::Message {
 public:
  Timing();
  virtual ~Timing();

  Timing(const Timing& from);

  inline Timing& operator=(const Timing& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Timing& default_instance();

  void Swap(Timing* other);

  // implements Message ----------------------------------------------

  Timing* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Timing& from);
  void MergeFrom(const Timing& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float blue_total = 1;
  inline bool has_blue_total() const;
  inline void clear_blue_total();
  static const int kBlueTotalFieldNumber = 1;
  inline float blue_total() const;
  inline void set_blue_total(float value);

  // optional float blue_path = 2;
  inline bool has_blue_path() const;
  inline void clear_blue_path();
  static const int kBluePathFieldNumber = 2;
  inline float blue_path() const;
  inline void set_blue_path(float value);

  // optional float yellow_total = 3;
  inline bool has_yellow_total() const;
  inline void clear_yellow_total();
  static const int kYellowTotalFieldNumber = 3;
  inline float yellow_total() const;
  inline void set_yellow_total(float value);

  // optional float yellow_path = 4;
  inline bool has_yellow_path() const;
  inline void clear_yellow_path();
  static const int kYellowPathFieldNumber = 4;
  inline float yellow_path() const;
  inline void set_yellow_path(float value);

  // optional float tracking = 5;
  inline bool has_tracking() const;
  inline void clear_tracking();
  static const int kTrackingFieldNumber = 5;
  inline float tracking() const;
  inline void set_tracking(float value);

  // optional float controller = 8;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 8;
  inline float controller() const;
  inline void set_controller(float value);

  // optional float transceiver = 6;
  inline bool has_transceiver() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 6;
  inline float transceiver() const;
  inline void set_transceiver(float value);

  // optional float transceiver_rtt = 9;
  inline bool has_transceiver_rtt() const;
  inline void clear_transceiver_rtt();
  static const int kTransceiverRttFieldNumber = 9;
  inline float transceiver_rtt() const;
  inline void set_transceiver_rtt(float value);

  // optional float simulator = 7;
  inline bool has_simulator() const;
  inline void clear_simulator();
  static const int kSimulatorFieldNumber = 7;
  inline float simulator() const;
  inline void set_simulator(float value);

  // @@protoc_insertion_point(class_scope:amun.Timing)
 private:
  inline void set_has_blue_total();
  inline void clear_has_blue_total();
  inline void set_has_blue_path();
  inline void clear_has_blue_path();
  inline void set_has_yellow_total();
  inline void clear_has_yellow_total();
  inline void set_has_yellow_path();
  inline void clear_has_yellow_path();
  inline void set_has_tracking();
  inline void clear_has_tracking();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_transceiver();
  inline void clear_has_transceiver();
  inline void set_has_transceiver_rtt();
  inline void clear_has_transceiver_rtt();
  inline void set_has_simulator();
  inline void clear_has_simulator();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float blue_total_;
  float blue_path_;
  float yellow_total_;
  float yellow_path_;
  float tracking_;
  float controller_;
  float transceiver_;
  float transceiver_rtt_;
  float simulator_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static Timing* default_instance_;
};
// -------------------------------------------------------------------

class StatusTransceiver : public ::google::protobuf::Message {
 public:
  StatusTransceiver();
  virtual ~StatusTransceiver();

  StatusTransceiver(const StatusTransceiver& from);

  inline StatusTransceiver& operator=(const StatusTransceiver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusTransceiver& default_instance();

  void Swap(StatusTransceiver* other);

  // implements Message ----------------------------------------------

  StatusTransceiver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusTransceiver& from);
  void MergeFrom(const StatusTransceiver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool active = 1;
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 1;
  inline bool active() const;
  inline void set_active(bool value);

  // optional string error = 2;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 2;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional int32 dropped_usb_packets = 3;
  inline bool has_dropped_usb_packets() const;
  inline void clear_dropped_usb_packets();
  static const int kDroppedUsbPacketsFieldNumber = 3;
  inline ::google::protobuf::int32 dropped_usb_packets() const;
  inline void set_dropped_usb_packets(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amun.StatusTransceiver)
 private:
  inline void set_has_active();
  inline void clear_has_active();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_dropped_usb_packets();
  inline void clear_has_dropped_usb_packets();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_;
  bool active_;
  ::google::protobuf::int32 dropped_usb_packets_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static StatusTransceiver* default_instance_;
};
// -------------------------------------------------------------------

class PortBindError : public ::google::protobuf::Message {
 public:
  PortBindError();
  virtual ~PortBindError();

  PortBindError(const PortBindError& from);

  inline PortBindError& operator=(const PortBindError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PortBindError& default_instance();

  void Swap(PortBindError* other);

  // implements Message ----------------------------------------------

  PortBindError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PortBindError& from);
  void MergeFrom(const PortBindError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 port = 1;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 1;
  inline ::google::protobuf::uint32 port() const;
  inline void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:amun.PortBindError)
 private:
  inline void set_has_port();
  inline void clear_has_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static PortBindError* default_instance_;
};
// -------------------------------------------------------------------

class StatusAmun : public ::google::protobuf::Message {
 public:
  StatusAmun();
  virtual ~StatusAmun();

  StatusAmun(const StatusAmun& from);

  inline StatusAmun& operator=(const StatusAmun& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusAmun& default_instance();

  void Swap(StatusAmun* other);

  // implements Message ----------------------------------------------

  StatusAmun* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusAmun& from);
  void MergeFrom(const StatusAmun& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .amun.PortBindError port_bind_error = 1;
  inline bool has_port_bind_error() const;
  inline void clear_port_bind_error();
  static const int kPortBindErrorFieldNumber = 1;
  inline const ::amun::PortBindError& port_bind_error() const;
  inline ::amun::PortBindError* mutable_port_bind_error();
  inline ::amun::PortBindError* release_port_bind_error();
  inline void set_allocated_port_bind_error(::amun::PortBindError* port_bind_error);

  // @@protoc_insertion_point(class_scope:amun.StatusAmun)
 private:
  inline void set_has_port_bind_error();
  inline void clear_has_port_bind_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::amun::PortBindError* port_bind_error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static StatusAmun* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional .amun.GameState game_state = 15;
  inline bool has_game_state() const;
  inline void clear_game_state();
  static const int kGameStateFieldNumber = 15;
  inline const ::amun::GameState& game_state() const;
  inline ::amun::GameState* mutable_game_state();
  inline ::amun::GameState* release_game_state();
  inline void set_allocated_game_state(::amun::GameState* game_state);

  // optional .world.State world_state = 3;
  inline bool has_world_state() const;
  inline void clear_world_state();
  static const int kWorldStateFieldNumber = 3;
  inline const ::world::State& world_state() const;
  inline ::world::State* mutable_world_state();
  inline ::world::State* release_world_state();
  inline void set_allocated_world_state(::world::State* world_state);

  // optional .world.Geometry geometry = 4;
  inline bool has_geometry() const;
  inline void clear_geometry();
  static const int kGeometryFieldNumber = 4;
  inline const ::world::Geometry& geometry() const;
  inline ::world::Geometry* mutable_geometry();
  inline ::world::Geometry* release_geometry();
  inline void set_allocated_geometry(::world::Geometry* geometry);

  // optional .robot.Team team_blue = 5;
  inline bool has_team_blue() const;
  inline void clear_team_blue();
  static const int kTeamBlueFieldNumber = 5;
  inline const ::robot::Team& team_blue() const;
  inline ::robot::Team* mutable_team_blue();
  inline ::robot::Team* release_team_blue();
  inline void set_allocated_team_blue(::robot::Team* team_blue);

  // optional .robot.Team team_yellow = 6;
  inline bool has_team_yellow() const;
  inline void clear_team_yellow();
  static const int kTeamYellowFieldNumber = 6;
  inline const ::robot::Team& team_yellow() const;
  inline ::robot::Team* mutable_team_yellow();
  inline ::robot::Team* release_team_yellow();
  inline void set_allocated_team_yellow(::robot::Team* team_yellow);

  // optional .amun.StatusStrategy strategy_blue = 7;
  inline bool has_strategy_blue() const;
  inline void clear_strategy_blue();
  static const int kStrategyBlueFieldNumber = 7;
  inline const ::amun::StatusStrategy& strategy_blue() const;
  inline ::amun::StatusStrategy* mutable_strategy_blue();
  inline ::amun::StatusStrategy* release_strategy_blue();
  inline void set_allocated_strategy_blue(::amun::StatusStrategy* strategy_blue);

  // optional .amun.StatusStrategy strategy_yellow = 8;
  inline bool has_strategy_yellow() const;
  inline void clear_strategy_yellow();
  static const int kStrategyYellowFieldNumber = 8;
  inline const ::amun::StatusStrategy& strategy_yellow() const;
  inline ::amun::StatusStrategy* mutable_strategy_yellow();
  inline ::amun::StatusStrategy* release_strategy_yellow();
  inline void set_allocated_strategy_yellow(::amun::StatusStrategy* strategy_yellow);

  // optional .amun.StatusStrategy strategy_autoref = 18;
  inline bool has_strategy_autoref() const;
  inline void clear_strategy_autoref();
  static const int kStrategyAutorefFieldNumber = 18;
  inline const ::amun::StatusStrategy& strategy_autoref() const;
  inline ::amun::StatusStrategy* mutable_strategy_autoref();
  inline ::amun::StatusStrategy* release_strategy_autoref();
  inline void set_allocated_strategy_autoref(::amun::StatusStrategy* strategy_autoref);

  // optional .amun.DebugValues debug = 10;
  inline bool has_debug() const;
  inline void clear_debug();
  static const int kDebugFieldNumber = 10;
  inline const ::amun::DebugValues& debug() const;
  inline ::amun::DebugValues* mutable_debug();
  inline ::amun::DebugValues* release_debug();
  inline void set_allocated_debug(::amun::DebugValues* debug);

  // optional .amun.Timing timing = 11;
  inline bool has_timing() const;
  inline void clear_timing();
  static const int kTimingFieldNumber = 11;
  inline const ::amun::Timing& timing() const;
  inline ::amun::Timing* mutable_timing();
  inline ::amun::Timing* release_timing();
  inline void set_allocated_timing(::amun::Timing* timing);

  // repeated .robot.RadioCommand radio_command = 12;
  inline int radio_command_size() const;
  inline void clear_radio_command();
  static const int kRadioCommandFieldNumber = 12;
  inline const ::robot::RadioCommand& radio_command(int index) const;
  inline ::robot::RadioCommand* mutable_radio_command(int index);
  inline ::robot::RadioCommand* add_radio_command();
  inline const ::google::protobuf::RepeatedPtrField< ::robot::RadioCommand >&
      radio_command() const;
  inline ::google::protobuf::RepeatedPtrField< ::robot::RadioCommand >*
      mutable_radio_command();

  // optional .amun.StatusTransceiver transceiver = 13;
  inline bool has_transceiver() const;
  inline void clear_transceiver();
  static const int kTransceiverFieldNumber = 13;
  inline const ::amun::StatusTransceiver& transceiver() const;
  inline ::amun::StatusTransceiver* mutable_transceiver();
  inline ::amun::StatusTransceiver* release_transceiver();
  inline void set_allocated_transceiver(::amun::StatusTransceiver* transceiver);

  // optional .amun.UserInput user_input_blue = 16;
  inline bool has_user_input_blue() const;
  inline void clear_user_input_blue();
  static const int kUserInputBlueFieldNumber = 16;
  inline const ::amun::UserInput& user_input_blue() const;
  inline ::amun::UserInput* mutable_user_input_blue();
  inline ::amun::UserInput* release_user_input_blue();
  inline void set_allocated_user_input_blue(::amun::UserInput* user_input_blue);

  // optional .amun.UserInput user_input_yellow = 17;
  inline bool has_user_input_yellow() const;
  inline void clear_user_input_yellow();
  static const int kUserInputYellowFieldNumber = 17;
  inline const ::amun::UserInput& user_input_yellow() const;
  inline ::amun::UserInput* mutable_user_input_yellow();
  inline ::amun::UserInput* release_user_input_yellow();
  inline void set_allocated_user_input_yellow(::amun::UserInput* user_input_yellow);

  // optional .amun.StatusAmun amun_state = 19;
  inline bool has_amun_state() const;
  inline void clear_amun_state();
  static const int kAmunStateFieldNumber = 19;
  inline const ::amun::StatusAmun& amun_state() const;
  inline ::amun::StatusAmun* mutable_amun_state();
  inline ::amun::StatusAmun* release_amun_state();
  inline void set_allocated_amun_state(::amun::StatusAmun* amun_state);

  // @@protoc_insertion_point(class_scope:amun.Status)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_game_state();
  inline void clear_has_game_state();
  inline void set_has_world_state();
  inline void clear_has_world_state();
  inline void set_has_geometry();
  inline void clear_has_geometry();
  inline void set_has_team_blue();
  inline void clear_has_team_blue();
  inline void set_has_team_yellow();
  inline void clear_has_team_yellow();
  inline void set_has_strategy_blue();
  inline void clear_has_strategy_blue();
  inline void set_has_strategy_yellow();
  inline void clear_has_strategy_yellow();
  inline void set_has_strategy_autoref();
  inline void clear_has_strategy_autoref();
  inline void set_has_debug();
  inline void clear_has_debug();
  inline void set_has_timing();
  inline void clear_has_timing();
  inline void set_has_transceiver();
  inline void clear_has_transceiver();
  inline void set_has_user_input_blue();
  inline void clear_has_user_input_blue();
  inline void set_has_user_input_yellow();
  inline void clear_has_user_input_yellow();
  inline void set_has_amun_state();
  inline void clear_has_amun_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::amun::GameState* game_state_;
  ::world::State* world_state_;
  ::world::Geometry* geometry_;
  ::robot::Team* team_blue_;
  ::robot::Team* team_yellow_;
  ::amun::StatusStrategy* strategy_blue_;
  ::amun::StatusStrategy* strategy_yellow_;
  ::amun::StatusStrategy* strategy_autoref_;
  ::amun::DebugValues* debug_;
  ::amun::Timing* timing_;
  ::google::protobuf::RepeatedPtrField< ::robot::RadioCommand > radio_command_;
  ::amun::StatusTransceiver* transceiver_;
  ::amun::UserInput* user_input_blue_;
  ::amun::UserInput* user_input_yellow_;
  ::amun::StatusAmun* amun_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_status_2eproto();
  friend void protobuf_AssignDesc_status_2eproto();
  friend void protobuf_ShutdownFile_status_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// ===================================================================


// ===================================================================

// StatusStrategy

// required .amun.StatusStrategy.STATE state = 1;
inline bool StatusStrategy::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusStrategy::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusStrategy::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusStrategy::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::amun::StatusStrategy_STATE StatusStrategy::state() const {
  return static_cast< ::amun::StatusStrategy_STATE >(state_);
}
inline void StatusStrategy::set_state(::amun::StatusStrategy_STATE value) {
  assert(::amun::StatusStrategy_STATE_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional string filename = 2;
inline bool StatusStrategy::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusStrategy::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusStrategy::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusStrategy::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& StatusStrategy::filename() const {
  return *filename_;
}
inline void StatusStrategy::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StatusStrategy::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void StatusStrategy::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusStrategy::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* StatusStrategy::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusStrategy::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool StatusStrategy::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusStrategy::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusStrategy::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusStrategy::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StatusStrategy::name() const {
  return *name_;
}
inline void StatusStrategy::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatusStrategy::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatusStrategy::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusStrategy::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StatusStrategy::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusStrategy::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string current_entry_point = 4;
inline bool StatusStrategy::has_current_entry_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatusStrategy::set_has_current_entry_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatusStrategy::clear_has_current_entry_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatusStrategy::clear_current_entry_point() {
  if (current_entry_point_ != &::google::protobuf::internal::kEmptyString) {
    current_entry_point_->clear();
  }
  clear_has_current_entry_point();
}
inline const ::std::string& StatusStrategy::current_entry_point() const {
  return *current_entry_point_;
}
inline void StatusStrategy::set_current_entry_point(const ::std::string& value) {
  set_has_current_entry_point();
  if (current_entry_point_ == &::google::protobuf::internal::kEmptyString) {
    current_entry_point_ = new ::std::string;
  }
  current_entry_point_->assign(value);
}
inline void StatusStrategy::set_current_entry_point(const char* value) {
  set_has_current_entry_point();
  if (current_entry_point_ == &::google::protobuf::internal::kEmptyString) {
    current_entry_point_ = new ::std::string;
  }
  current_entry_point_->assign(value);
}
inline void StatusStrategy::set_current_entry_point(const char* value, size_t size) {
  set_has_current_entry_point();
  if (current_entry_point_ == &::google::protobuf::internal::kEmptyString) {
    current_entry_point_ = new ::std::string;
  }
  current_entry_point_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusStrategy::mutable_current_entry_point() {
  set_has_current_entry_point();
  if (current_entry_point_ == &::google::protobuf::internal::kEmptyString) {
    current_entry_point_ = new ::std::string;
  }
  return current_entry_point_;
}
inline ::std::string* StatusStrategy::release_current_entry_point() {
  clear_has_current_entry_point();
  if (current_entry_point_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = current_entry_point_;
    current_entry_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusStrategy::set_allocated_current_entry_point(::std::string* current_entry_point) {
  if (current_entry_point_ != &::google::protobuf::internal::kEmptyString) {
    delete current_entry_point_;
  }
  if (current_entry_point) {
    set_has_current_entry_point();
    current_entry_point_ = current_entry_point;
  } else {
    clear_has_current_entry_point();
    current_entry_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string entry_point = 5;
inline int StatusStrategy::entry_point_size() const {
  return entry_point_.size();
}
inline void StatusStrategy::clear_entry_point() {
  entry_point_.Clear();
}
inline const ::std::string& StatusStrategy::entry_point(int index) const {
  return entry_point_.Get(index);
}
inline ::std::string* StatusStrategy::mutable_entry_point(int index) {
  return entry_point_.Mutable(index);
}
inline void StatusStrategy::set_entry_point(int index, const ::std::string& value) {
  entry_point_.Mutable(index)->assign(value);
}
inline void StatusStrategy::set_entry_point(int index, const char* value) {
  entry_point_.Mutable(index)->assign(value);
}
inline void StatusStrategy::set_entry_point(int index, const char* value, size_t size) {
  entry_point_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusStrategy::add_entry_point() {
  return entry_point_.Add();
}
inline void StatusStrategy::add_entry_point(const ::std::string& value) {
  entry_point_.Add()->assign(value);
}
inline void StatusStrategy::add_entry_point(const char* value) {
  entry_point_.Add()->assign(value);
}
inline void StatusStrategy::add_entry_point(const char* value, size_t size) {
  entry_point_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StatusStrategy::entry_point() const {
  return entry_point_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StatusStrategy::mutable_entry_point() {
  return &entry_point_;
}

// -------------------------------------------------------------------

// Timing

// optional float blue_total = 1;
inline bool Timing::has_blue_total() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Timing::set_has_blue_total() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Timing::clear_has_blue_total() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Timing::clear_blue_total() {
  blue_total_ = 0;
  clear_has_blue_total();
}
inline float Timing::blue_total() const {
  return blue_total_;
}
inline void Timing::set_blue_total(float value) {
  set_has_blue_total();
  blue_total_ = value;
}

// optional float blue_path = 2;
inline bool Timing::has_blue_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Timing::set_has_blue_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Timing::clear_has_blue_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Timing::clear_blue_path() {
  blue_path_ = 0;
  clear_has_blue_path();
}
inline float Timing::blue_path() const {
  return blue_path_;
}
inline void Timing::set_blue_path(float value) {
  set_has_blue_path();
  blue_path_ = value;
}

// optional float yellow_total = 3;
inline bool Timing::has_yellow_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Timing::set_has_yellow_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Timing::clear_has_yellow_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Timing::clear_yellow_total() {
  yellow_total_ = 0;
  clear_has_yellow_total();
}
inline float Timing::yellow_total() const {
  return yellow_total_;
}
inline void Timing::set_yellow_total(float value) {
  set_has_yellow_total();
  yellow_total_ = value;
}

// optional float yellow_path = 4;
inline bool Timing::has_yellow_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Timing::set_has_yellow_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Timing::clear_has_yellow_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Timing::clear_yellow_path() {
  yellow_path_ = 0;
  clear_has_yellow_path();
}
inline float Timing::yellow_path() const {
  return yellow_path_;
}
inline void Timing::set_yellow_path(float value) {
  set_has_yellow_path();
  yellow_path_ = value;
}

// optional float tracking = 5;
inline bool Timing::has_tracking() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Timing::set_has_tracking() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Timing::clear_has_tracking() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Timing::clear_tracking() {
  tracking_ = 0;
  clear_has_tracking();
}
inline float Timing::tracking() const {
  return tracking_;
}
inline void Timing::set_tracking(float value) {
  set_has_tracking();
  tracking_ = value;
}

// optional float controller = 8;
inline bool Timing::has_controller() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Timing::set_has_controller() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Timing::clear_has_controller() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Timing::clear_controller() {
  controller_ = 0;
  clear_has_controller();
}
inline float Timing::controller() const {
  return controller_;
}
inline void Timing::set_controller(float value) {
  set_has_controller();
  controller_ = value;
}

// optional float transceiver = 6;
inline bool Timing::has_transceiver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Timing::set_has_transceiver() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Timing::clear_has_transceiver() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Timing::clear_transceiver() {
  transceiver_ = 0;
  clear_has_transceiver();
}
inline float Timing::transceiver() const {
  return transceiver_;
}
inline void Timing::set_transceiver(float value) {
  set_has_transceiver();
  transceiver_ = value;
}

// optional float transceiver_rtt = 9;
inline bool Timing::has_transceiver_rtt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Timing::set_has_transceiver_rtt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Timing::clear_has_transceiver_rtt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Timing::clear_transceiver_rtt() {
  transceiver_rtt_ = 0;
  clear_has_transceiver_rtt();
}
inline float Timing::transceiver_rtt() const {
  return transceiver_rtt_;
}
inline void Timing::set_transceiver_rtt(float value) {
  set_has_transceiver_rtt();
  transceiver_rtt_ = value;
}

// optional float simulator = 7;
inline bool Timing::has_simulator() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Timing::set_has_simulator() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Timing::clear_has_simulator() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Timing::clear_simulator() {
  simulator_ = 0;
  clear_has_simulator();
}
inline float Timing::simulator() const {
  return simulator_;
}
inline void Timing::set_simulator(float value) {
  set_has_simulator();
  simulator_ = value;
}

// -------------------------------------------------------------------

// StatusTransceiver

// required bool active = 1;
inline bool StatusTransceiver::has_active() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusTransceiver::set_has_active() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusTransceiver::clear_has_active() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusTransceiver::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool StatusTransceiver::active() const {
  return active_;
}
inline void StatusTransceiver::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// optional string error = 2;
inline bool StatusTransceiver::has_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusTransceiver::set_has_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusTransceiver::clear_has_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusTransceiver::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& StatusTransceiver::error() const {
  return *error_;
}
inline void StatusTransceiver::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void StatusTransceiver::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void StatusTransceiver::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatusTransceiver::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* StatusTransceiver::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatusTransceiver::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 dropped_usb_packets = 3;
inline bool StatusTransceiver::has_dropped_usb_packets() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusTransceiver::set_has_dropped_usb_packets() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusTransceiver::clear_has_dropped_usb_packets() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusTransceiver::clear_dropped_usb_packets() {
  dropped_usb_packets_ = 0;
  clear_has_dropped_usb_packets();
}
inline ::google::protobuf::int32 StatusTransceiver::dropped_usb_packets() const {
  return dropped_usb_packets_;
}
inline void StatusTransceiver::set_dropped_usb_packets(::google::protobuf::int32 value) {
  set_has_dropped_usb_packets();
  dropped_usb_packets_ = value;
}

// -------------------------------------------------------------------

// PortBindError

// required uint32 port = 1;
inline bool PortBindError::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PortBindError::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PortBindError::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PortBindError::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 PortBindError::port() const {
  return port_;
}
inline void PortBindError::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
}

// -------------------------------------------------------------------

// StatusAmun

// optional .amun.PortBindError port_bind_error = 1;
inline bool StatusAmun::has_port_bind_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusAmun::set_has_port_bind_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusAmun::clear_has_port_bind_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusAmun::clear_port_bind_error() {
  if (port_bind_error_ != NULL) port_bind_error_->::amun::PortBindError::Clear();
  clear_has_port_bind_error();
}
inline const ::amun::PortBindError& StatusAmun::port_bind_error() const {
  return port_bind_error_ != NULL ? *port_bind_error_ : *default_instance_->port_bind_error_;
}
inline ::amun::PortBindError* StatusAmun::mutable_port_bind_error() {
  set_has_port_bind_error();
  if (port_bind_error_ == NULL) port_bind_error_ = new ::amun::PortBindError;
  return port_bind_error_;
}
inline ::amun::PortBindError* StatusAmun::release_port_bind_error() {
  clear_has_port_bind_error();
  ::amun::PortBindError* temp = port_bind_error_;
  port_bind_error_ = NULL;
  return temp;
}
inline void StatusAmun::set_allocated_port_bind_error(::amun::PortBindError* port_bind_error) {
  delete port_bind_error_;
  port_bind_error_ = port_bind_error;
  if (port_bind_error) {
    set_has_port_bind_error();
  } else {
    clear_has_port_bind_error();
  }
}

// -------------------------------------------------------------------

// Status

// required int64 time = 1;
inline bool Status::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 Status::time() const {
  return time_;
}
inline void Status::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional .amun.GameState game_state = 15;
inline bool Status::has_game_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Status::set_has_game_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Status::clear_has_game_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Status::clear_game_state() {
  if (game_state_ != NULL) game_state_->::amun::GameState::Clear();
  clear_has_game_state();
}
inline const ::amun::GameState& Status::game_state() const {
  return game_state_ != NULL ? *game_state_ : *default_instance_->game_state_;
}
inline ::amun::GameState* Status::mutable_game_state() {
  set_has_game_state();
  if (game_state_ == NULL) game_state_ = new ::amun::GameState;
  return game_state_;
}
inline ::amun::GameState* Status::release_game_state() {
  clear_has_game_state();
  ::amun::GameState* temp = game_state_;
  game_state_ = NULL;
  return temp;
}
inline void Status::set_allocated_game_state(::amun::GameState* game_state) {
  delete game_state_;
  game_state_ = game_state;
  if (game_state) {
    set_has_game_state();
  } else {
    clear_has_game_state();
  }
}

// optional .world.State world_state = 3;
inline bool Status::has_world_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Status::set_has_world_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Status::clear_has_world_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Status::clear_world_state() {
  if (world_state_ != NULL) world_state_->::world::State::Clear();
  clear_has_world_state();
}
inline const ::world::State& Status::world_state() const {
  return world_state_ != NULL ? *world_state_ : *default_instance_->world_state_;
}
inline ::world::State* Status::mutable_world_state() {
  set_has_world_state();
  if (world_state_ == NULL) world_state_ = new ::world::State;
  return world_state_;
}
inline ::world::State* Status::release_world_state() {
  clear_has_world_state();
  ::world::State* temp = world_state_;
  world_state_ = NULL;
  return temp;
}
inline void Status::set_allocated_world_state(::world::State* world_state) {
  delete world_state_;
  world_state_ = world_state;
  if (world_state) {
    set_has_world_state();
  } else {
    clear_has_world_state();
  }
}

// optional .world.Geometry geometry = 4;
inline bool Status::has_geometry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Status::set_has_geometry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Status::clear_has_geometry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Status::clear_geometry() {
  if (geometry_ != NULL) geometry_->::world::Geometry::Clear();
  clear_has_geometry();
}
inline const ::world::Geometry& Status::geometry() const {
  return geometry_ != NULL ? *geometry_ : *default_instance_->geometry_;
}
inline ::world::Geometry* Status::mutable_geometry() {
  set_has_geometry();
  if (geometry_ == NULL) geometry_ = new ::world::Geometry;
  return geometry_;
}
inline ::world::Geometry* Status::release_geometry() {
  clear_has_geometry();
  ::world::Geometry* temp = geometry_;
  geometry_ = NULL;
  return temp;
}
inline void Status::set_allocated_geometry(::world::Geometry* geometry) {
  delete geometry_;
  geometry_ = geometry;
  if (geometry) {
    set_has_geometry();
  } else {
    clear_has_geometry();
  }
}

// optional .robot.Team team_blue = 5;
inline bool Status::has_team_blue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Status::set_has_team_blue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Status::clear_has_team_blue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Status::clear_team_blue() {
  if (team_blue_ != NULL) team_blue_->::robot::Team::Clear();
  clear_has_team_blue();
}
inline const ::robot::Team& Status::team_blue() const {
  return team_blue_ != NULL ? *team_blue_ : *default_instance_->team_blue_;
}
inline ::robot::Team* Status::mutable_team_blue() {
  set_has_team_blue();
  if (team_blue_ == NULL) team_blue_ = new ::robot::Team;
  return team_blue_;
}
inline ::robot::Team* Status::release_team_blue() {
  clear_has_team_blue();
  ::robot::Team* temp = team_blue_;
  team_blue_ = NULL;
  return temp;
}
inline void Status::set_allocated_team_blue(::robot::Team* team_blue) {
  delete team_blue_;
  team_blue_ = team_blue;
  if (team_blue) {
    set_has_team_blue();
  } else {
    clear_has_team_blue();
  }
}

// optional .robot.Team team_yellow = 6;
inline bool Status::has_team_yellow() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Status::set_has_team_yellow() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Status::clear_has_team_yellow() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Status::clear_team_yellow() {
  if (team_yellow_ != NULL) team_yellow_->::robot::Team::Clear();
  clear_has_team_yellow();
}
inline const ::robot::Team& Status::team_yellow() const {
  return team_yellow_ != NULL ? *team_yellow_ : *default_instance_->team_yellow_;
}
inline ::robot::Team* Status::mutable_team_yellow() {
  set_has_team_yellow();
  if (team_yellow_ == NULL) team_yellow_ = new ::robot::Team;
  return team_yellow_;
}
inline ::robot::Team* Status::release_team_yellow() {
  clear_has_team_yellow();
  ::robot::Team* temp = team_yellow_;
  team_yellow_ = NULL;
  return temp;
}
inline void Status::set_allocated_team_yellow(::robot::Team* team_yellow) {
  delete team_yellow_;
  team_yellow_ = team_yellow;
  if (team_yellow) {
    set_has_team_yellow();
  } else {
    clear_has_team_yellow();
  }
}

// optional .amun.StatusStrategy strategy_blue = 7;
inline bool Status::has_strategy_blue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Status::set_has_strategy_blue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Status::clear_has_strategy_blue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Status::clear_strategy_blue() {
  if (strategy_blue_ != NULL) strategy_blue_->::amun::StatusStrategy::Clear();
  clear_has_strategy_blue();
}
inline const ::amun::StatusStrategy& Status::strategy_blue() const {
  return strategy_blue_ != NULL ? *strategy_blue_ : *default_instance_->strategy_blue_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_blue() {
  set_has_strategy_blue();
  if (strategy_blue_ == NULL) strategy_blue_ = new ::amun::StatusStrategy;
  return strategy_blue_;
}
inline ::amun::StatusStrategy* Status::release_strategy_blue() {
  clear_has_strategy_blue();
  ::amun::StatusStrategy* temp = strategy_blue_;
  strategy_blue_ = NULL;
  return temp;
}
inline void Status::set_allocated_strategy_blue(::amun::StatusStrategy* strategy_blue) {
  delete strategy_blue_;
  strategy_blue_ = strategy_blue;
  if (strategy_blue) {
    set_has_strategy_blue();
  } else {
    clear_has_strategy_blue();
  }
}

// optional .amun.StatusStrategy strategy_yellow = 8;
inline bool Status::has_strategy_yellow() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Status::set_has_strategy_yellow() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Status::clear_has_strategy_yellow() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Status::clear_strategy_yellow() {
  if (strategy_yellow_ != NULL) strategy_yellow_->::amun::StatusStrategy::Clear();
  clear_has_strategy_yellow();
}
inline const ::amun::StatusStrategy& Status::strategy_yellow() const {
  return strategy_yellow_ != NULL ? *strategy_yellow_ : *default_instance_->strategy_yellow_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_yellow() {
  set_has_strategy_yellow();
  if (strategy_yellow_ == NULL) strategy_yellow_ = new ::amun::StatusStrategy;
  return strategy_yellow_;
}
inline ::amun::StatusStrategy* Status::release_strategy_yellow() {
  clear_has_strategy_yellow();
  ::amun::StatusStrategy* temp = strategy_yellow_;
  strategy_yellow_ = NULL;
  return temp;
}
inline void Status::set_allocated_strategy_yellow(::amun::StatusStrategy* strategy_yellow) {
  delete strategy_yellow_;
  strategy_yellow_ = strategy_yellow;
  if (strategy_yellow) {
    set_has_strategy_yellow();
  } else {
    clear_has_strategy_yellow();
  }
}

// optional .amun.StatusStrategy strategy_autoref = 18;
inline bool Status::has_strategy_autoref() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Status::set_has_strategy_autoref() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Status::clear_has_strategy_autoref() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Status::clear_strategy_autoref() {
  if (strategy_autoref_ != NULL) strategy_autoref_->::amun::StatusStrategy::Clear();
  clear_has_strategy_autoref();
}
inline const ::amun::StatusStrategy& Status::strategy_autoref() const {
  return strategy_autoref_ != NULL ? *strategy_autoref_ : *default_instance_->strategy_autoref_;
}
inline ::amun::StatusStrategy* Status::mutable_strategy_autoref() {
  set_has_strategy_autoref();
  if (strategy_autoref_ == NULL) strategy_autoref_ = new ::amun::StatusStrategy;
  return strategy_autoref_;
}
inline ::amun::StatusStrategy* Status::release_strategy_autoref() {
  clear_has_strategy_autoref();
  ::amun::StatusStrategy* temp = strategy_autoref_;
  strategy_autoref_ = NULL;
  return temp;
}
inline void Status::set_allocated_strategy_autoref(::amun::StatusStrategy* strategy_autoref) {
  delete strategy_autoref_;
  strategy_autoref_ = strategy_autoref;
  if (strategy_autoref) {
    set_has_strategy_autoref();
  } else {
    clear_has_strategy_autoref();
  }
}

// optional .amun.DebugValues debug = 10;
inline bool Status::has_debug() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Status::set_has_debug() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Status::clear_has_debug() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Status::clear_debug() {
  if (debug_ != NULL) debug_->::amun::DebugValues::Clear();
  clear_has_debug();
}
inline const ::amun::DebugValues& Status::debug() const {
  return debug_ != NULL ? *debug_ : *default_instance_->debug_;
}
inline ::amun::DebugValues* Status::mutable_debug() {
  set_has_debug();
  if (debug_ == NULL) debug_ = new ::amun::DebugValues;
  return debug_;
}
inline ::amun::DebugValues* Status::release_debug() {
  clear_has_debug();
  ::amun::DebugValues* temp = debug_;
  debug_ = NULL;
  return temp;
}
inline void Status::set_allocated_debug(::amun::DebugValues* debug) {
  delete debug_;
  debug_ = debug;
  if (debug) {
    set_has_debug();
  } else {
    clear_has_debug();
  }
}

// optional .amun.Timing timing = 11;
inline bool Status::has_timing() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Status::set_has_timing() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Status::clear_has_timing() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Status::clear_timing() {
  if (timing_ != NULL) timing_->::amun::Timing::Clear();
  clear_has_timing();
}
inline const ::amun::Timing& Status::timing() const {
  return timing_ != NULL ? *timing_ : *default_instance_->timing_;
}
inline ::amun::Timing* Status::mutable_timing() {
  set_has_timing();
  if (timing_ == NULL) timing_ = new ::amun::Timing;
  return timing_;
}
inline ::amun::Timing* Status::release_timing() {
  clear_has_timing();
  ::amun::Timing* temp = timing_;
  timing_ = NULL;
  return temp;
}
inline void Status::set_allocated_timing(::amun::Timing* timing) {
  delete timing_;
  timing_ = timing;
  if (timing) {
    set_has_timing();
  } else {
    clear_has_timing();
  }
}

// repeated .robot.RadioCommand radio_command = 12;
inline int Status::radio_command_size() const {
  return radio_command_.size();
}
inline void Status::clear_radio_command() {
  radio_command_.Clear();
}
inline const ::robot::RadioCommand& Status::radio_command(int index) const {
  return radio_command_.Get(index);
}
inline ::robot::RadioCommand* Status::mutable_radio_command(int index) {
  return radio_command_.Mutable(index);
}
inline ::robot::RadioCommand* Status::add_radio_command() {
  return radio_command_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::robot::RadioCommand >&
Status::radio_command() const {
  return radio_command_;
}
inline ::google::protobuf::RepeatedPtrField< ::robot::RadioCommand >*
Status::mutable_radio_command() {
  return &radio_command_;
}

// optional .amun.StatusTransceiver transceiver = 13;
inline bool Status::has_transceiver() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Status::set_has_transceiver() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Status::clear_has_transceiver() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Status::clear_transceiver() {
  if (transceiver_ != NULL) transceiver_->::amun::StatusTransceiver::Clear();
  clear_has_transceiver();
}
inline const ::amun::StatusTransceiver& Status::transceiver() const {
  return transceiver_ != NULL ? *transceiver_ : *default_instance_->transceiver_;
}
inline ::amun::StatusTransceiver* Status::mutable_transceiver() {
  set_has_transceiver();
  if (transceiver_ == NULL) transceiver_ = new ::amun::StatusTransceiver;
  return transceiver_;
}
inline ::amun::StatusTransceiver* Status::release_transceiver() {
  clear_has_transceiver();
  ::amun::StatusTransceiver* temp = transceiver_;
  transceiver_ = NULL;
  return temp;
}
inline void Status::set_allocated_transceiver(::amun::StatusTransceiver* transceiver) {
  delete transceiver_;
  transceiver_ = transceiver;
  if (transceiver) {
    set_has_transceiver();
  } else {
    clear_has_transceiver();
  }
}

// optional .amun.UserInput user_input_blue = 16;
inline bool Status::has_user_input_blue() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Status::set_has_user_input_blue() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Status::clear_has_user_input_blue() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Status::clear_user_input_blue() {
  if (user_input_blue_ != NULL) user_input_blue_->::amun::UserInput::Clear();
  clear_has_user_input_blue();
}
inline const ::amun::UserInput& Status::user_input_blue() const {
  return user_input_blue_ != NULL ? *user_input_blue_ : *default_instance_->user_input_blue_;
}
inline ::amun::UserInput* Status::mutable_user_input_blue() {
  set_has_user_input_blue();
  if (user_input_blue_ == NULL) user_input_blue_ = new ::amun::UserInput;
  return user_input_blue_;
}
inline ::amun::UserInput* Status::release_user_input_blue() {
  clear_has_user_input_blue();
  ::amun::UserInput* temp = user_input_blue_;
  user_input_blue_ = NULL;
  return temp;
}
inline void Status::set_allocated_user_input_blue(::amun::UserInput* user_input_blue) {
  delete user_input_blue_;
  user_input_blue_ = user_input_blue;
  if (user_input_blue) {
    set_has_user_input_blue();
  } else {
    clear_has_user_input_blue();
  }
}

// optional .amun.UserInput user_input_yellow = 17;
inline bool Status::has_user_input_yellow() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Status::set_has_user_input_yellow() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Status::clear_has_user_input_yellow() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Status::clear_user_input_yellow() {
  if (user_input_yellow_ != NULL) user_input_yellow_->::amun::UserInput::Clear();
  clear_has_user_input_yellow();
}
inline const ::amun::UserInput& Status::user_input_yellow() const {
  return user_input_yellow_ != NULL ? *user_input_yellow_ : *default_instance_->user_input_yellow_;
}
inline ::amun::UserInput* Status::mutable_user_input_yellow() {
  set_has_user_input_yellow();
  if (user_input_yellow_ == NULL) user_input_yellow_ = new ::amun::UserInput;
  return user_input_yellow_;
}
inline ::amun::UserInput* Status::release_user_input_yellow() {
  clear_has_user_input_yellow();
  ::amun::UserInput* temp = user_input_yellow_;
  user_input_yellow_ = NULL;
  return temp;
}
inline void Status::set_allocated_user_input_yellow(::amun::UserInput* user_input_yellow) {
  delete user_input_yellow_;
  user_input_yellow_ = user_input_yellow;
  if (user_input_yellow) {
    set_has_user_input_yellow();
  } else {
    clear_has_user_input_yellow();
  }
}

// optional .amun.StatusAmun amun_state = 19;
inline bool Status::has_amun_state() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Status::set_has_amun_state() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Status::clear_has_amun_state() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Status::clear_amun_state() {
  if (amun_state_ != NULL) amun_state_->::amun::StatusAmun::Clear();
  clear_has_amun_state();
}
inline const ::amun::StatusAmun& Status::amun_state() const {
  return amun_state_ != NULL ? *amun_state_ : *default_instance_->amun_state_;
}
inline ::amun::StatusAmun* Status::mutable_amun_state() {
  set_has_amun_state();
  if (amun_state_ == NULL) amun_state_ = new ::amun::StatusAmun;
  return amun_state_;
}
inline ::amun::StatusAmun* Status::release_amun_state() {
  clear_has_amun_state();
  ::amun::StatusAmun* temp = amun_state_;
  amun_state_ = NULL;
  return temp;
}
inline void Status::set_allocated_amun_state(::amun::StatusAmun* amun_state) {
  delete amun_state_;
  amun_state_ = amun_state;
  if (amun_state) {
    set_has_amun_state();
  } else {
    clear_has_amun_state();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace amun

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::amun::StatusStrategy_STATE>() {
  return ::amun::StatusStrategy_STATE_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_status_2eproto__INCLUDED
